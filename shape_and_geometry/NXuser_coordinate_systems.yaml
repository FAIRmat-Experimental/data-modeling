category: base
(NXuser_coordinate_systems):
  # implementing a proposal for "a common base table" along thoughts like:
  # https://manual.nexusformat.org/classes/base_classes/NXtransformations.html#nxtransformations
  # similar to a place where all transformations are stored
  # https://www.zenodo.org/record/3526738/files/lyso009a_0087.JF07T32V01_master.h5?download=1
  doc: |
    Base class to hold different coordinate systems that should be distinguished for a measurement and related processing steps.
    
    By default NeXus uses the McStas coordinate system, whose axis convention 
    is so that the z axis is along the neutron propagation axis, 
    the y axis is vertical up, and the x axis points left when looking along
    the z-axis, completing a right-handed coordinate system.
    Assuming the McStas coordinate system as the reference, indicated by ".",
    this base.
  (NXtransformations):
  # these user-defined frames could be the sample surface, the detector,
  # individual frames attached to specific instruments, for instance in an
  # atom probe experiment we usually have a lab, specimen surface/apex, laser (pinhole), detector, reconstruction frames
  # in electron/focused ion beam, lab, e-beam, i-beam, sample surface, individual frames for each detector

  # THE REMAINING TEXT IS NOT PART OF THE BASE CLASS
  # An example follows how each field under transformations can look like
  # I would like to encourage a description where each coordinate system is defined
  # and for each coordinate system a transformation written down which maps each
  # user-defined Frame_i onto Frame_McStas (and maybe for convenience purposes also vice versa
  # Frame_McStas = T_i * Frame_i
  # if there would be a small python tool that takes a collection of frames
  # and does the mapping automatically and writing the respective NeXus entries
  # this would be very useful.

    # \@transformation_type should not be used
    # define frame of reference that is understood as the laboratory coordinate system
    x_axis(NX_NUMBER):
      unit: NX_TRANSFORMATION
      \@depends_on: # "." meaning the root coordinate system, i.e. the McStas
      \@vector(NX_NUMBER): # [1, 0, 0]
      # \@offset(NX_NUMBER):
    y_axis(NX_NUMBER):
      unit: NX_TRANSFORMATION
      \@depends_on: # "."
      \@vector(NX_NUMBER): # [0, 1, 0]
      # \@offset(NX_NUMBER):
    z_axis(NX_NUMBER):
      unit: NX_TRANSFORMATION
      \@depends_on: # "."
      \@vector(NX_NUMBER): # [0, 0, 1]
      \@offset(NX_NUMBER): # is [0, 0, 0] if the origin of the McStas coordinate system and of the laboratory_frame overlap
      # \@offset_units: # should be an NX_LENGTH
    # and how it translates into the McStas convention
    lab_mcstas(NX_NUMBER):
      doc: "Rotation matrix which maps the x_axis of the laboratory_frame to the x_axis of the McStas system."
      # BUT as far as I know you cannot define a 3D rotation matrix, you should rather make a chain of transformations
      # each about a single axis and thus building a depends_on chain
      # for example a 4x4 translation with a more-than-one-value-non-zero/non-identity rotation matrix
      # could be you first rotate about Z by R_Z'/R_1 depends_on is x_axis := X, yielding X', Y', Z'
      # second you rotate about the X' by R_X/R_2 depends_on is X', yielding X'', Y'', Z''
      # third you rotate about the Z'' by R_Z''/R_3 depends_on is then Z'', yielding X''', Y''', Z''' matching McStas,
      # this is the Bunge-Euler way of doing it, but would it also be possible to just define
      # the lab_mcstas(NX_NUMBER) value as an 3x3 array and give the offsets and translations as it is discussed in the manual ?
      unit: NX_ANGLE
      \@depends_on: # x_axis
    # !!! R is the usual rotation matrix 3x3 but at the same time "R is defined as a rotation 
    # !!! about an axis in the direction of vector, of angle of the field value."
    # !!! see https://manual.nexusformat.org/classes/base_classes/NXtransformations.html
    mcstas_to_lab(NX_NUMBER):
    # same story but the inverse affine transformation
