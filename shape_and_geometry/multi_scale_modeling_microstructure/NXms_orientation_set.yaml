category: base
(NXms_orientation_set):
  doc: |
    Orientations of objects.
    
    Base class with the intention to be used as a container which holds attribute data to a set of objects.
    The container stores a set of specifically parameterized NXtransformations which describe how each object
    is oriented/rotated with respect to a reference coordinate system.
  # we should offer here support for d==2, d==3
  symbols:
    n_p: "Number of parameters for the chosen parameterization. Will be used to specify the number of e.g. columns of a C-style matrix of Bunge-Euler angles, where each row is one Bunge-Euler angle triple."
    c: "Cardinality, number of orientations."
    d: "Dimensionality."
    # depending on the dimensionality n_p is correlated but not necessarily, e.g. for d==3 one can store quaternions (n_p==4) or Bunge-Euler angles (n_p==3)
    # clearly one could think about a single best approach that everybody should use, and indeed quaternions could be a candidate but this conflicts with the
    # expectations understanding and in fact habit by very many materials engineers who know and report their values in Euler angles so at least one would need to
    # have a system in place which converts...
  reference(NXtransformations):
  parameterization(NX_CHAR):
    enumeration: [bunge-euler (ZXZ), quaternion]  # there are many more ways of parameterizing orientations and for each of them different conventions to be used. many scientists do not recall by hard which rule set is associated with an e.g. ZXZ Bunge-Euler angles vers ZXY so there are at least two ways how to encode these metadata: Either to have different enumerations like bunge-euler-zxz, bunge-euler-zxy, etc. or a base class NXori_bunge_euler and then internally here a rule set...?
  # how to take into account the reduction to two-d? just list these cases XY, XZ, ... also in the enumeration?
  # an instance of an NXms_orientation_set is useful as attribute (meta)data to a set of microstructural objects e.g. crystals, grains when the base class is stored as a sub-ordinate of the grain_set
  # one may argue we expect that for each grain there is an orientation value, in this case the indexing is implicit and this often used in computer simulations
  # without making a specific statement that e.g. the 0-th value of the array gives the volume of the 0-th grain but that 0-th grain might not necessarily be named as grain 0 but e.g. grain 23
  # because many computer simulations deal with ensemble where the number of objects changes over time, e.g. molecular dynamics simulation treat always the same set of atoms but post-processing
  # of the data may reveal these atoms are grouped/labelled as different microstructural features (grains, dislocations, vacancies) and then the names/identifiers of the objects may change over time
  # therefore the idea to specify if we use implicit or explicit indexing and listing of the indices because I know of colleagues where even that went havoc!
  # implicit_identifier(NX_BOOLEAN):  # storage efficient strategy and at  the same time a distinct marker which informs users if the order is indeed as expected. Take for instance a set of grains with identifier values from 1, 2, 3, if the grain set has a field wich is an (NXorientation_set) and if implicit_identifier == true we know that the 0-th row of the orientation array quantifies the orientation of the 1 grain, the 1-th entry that of the 2 grain and so forth...
    doc: "If true, the identifiers run from a to b ?? what are useful values for a and b ???, and follow the order in the orientation list."  # needs better explanation.
  identifier(NX_UINT):
    doc: "List of identifier which specify which orientation (row of array orientation) matches to which object." # in the case of explicit indexing, enables for names to not be consecutive, as it is for instance the case in grain coarsening simulations where the number of grains and which specific grains disappear is practically unpredictable
  orientation(NX_NUMBER):
    doc: "Parameter values for each orientation."
    dimensions:
      rank: 2
      dim: [[1, c], [2, n_p]]  # e.g. in this way one could easily, efficiently, store and map familiar habits of microscopists to store e.g. orientations of measurement points or of grains via a (c := Ngrains, n_p := 3) matrix of Bunge-Euler angles, or of (c := Ngrains, n_p := 4) matrix of quaternions.

# the benefit of such a representation is that with a known NXms_orientation_set base class one can implement a common parameterization transformation library (of which several already exist) in the microstructure modelling communities so that a program can read the information in the (NXorientation_set) dataset portion instance and automatically transform/compute different parameterizations. Super relevant for interoperability e.g. in SEM/EBSD, where this was a long standing issue and right now the most frequently accepted "consensus" is to report either Bunge-Euler angles or quaternions and then use existent transformation libraries (as implemented by e.g. Marc de Graeff for SEM/EBSD and used by most people in the computational materials modelling community within crystal plasticity, crystal growth modeling, DREAM.3D.
