category: base
(NXms_crystal_set):
  doc: |
    A base class to wrap details about a set of crystals (grains, precipitates).
    
    There are two fundamentally different approaches how crystals are discretized
    in mesoscale (solid state transformation) microstructure evolution 
    simulations, irrespective whether these are precipitates, phase regions, 
    so-called sub-grains or grains:
    * Objects are either tracked explicitly in the sense that their shape will
      be resolved with e.g. a phase-field, level-set, grid, or finite element mesh.
      These simulations allow to track in each time step crystal-specific properties
      because the solver keeps explicitly track of crystal/grain/object-related
      quantities. Such simulation models often treat the interface network
      implicitly but may or not also compute an explicit evaluation of the interface
      network on-the-fly, because of technical demands (like in level-set)
      or to trigger specific situations where it is relevant to resolve the
      position of the interfaces explicitly (like for placing seeds for phases,
      recrystallizing grains etc).
      For explicitly tracking simulations this base class can be applied as is.
    * Objects are tracked implicitly in the sense that the computational domain 
      is discretized into an ensemble of what one can call material points.
      Each material point has then at least one associated constitutive phase.
      Such simulations usually do not/cannot resolve crystal-related quantities
      without executing an on-the-fly post-processing of snapshot data from
      which the spatial representation of the crystal is recovered.
      An important case are large-strain formalism crystal plasticity methods.
      Here the initial configuration represents most frequently material points
      on a regular grid. Within the course of the simulation this grid gets
      deformed implicitly. The code internally keeps no track of how the cells/
      material points of what is essentially a Voronoi tessellation, are deformed.
      Only in the case one would like to visualize the deformed configuration
      a post-processing of the simulation snapshot data is executed which
      backs out the positions of the material points in the deformed configuration
      from which one can then extract a representation of grains.
      It is a signature of such simulations that quantities like orientation
      are per material point quantities. This means what constitutes the grain
      needs to be extracted by cluster analyses. 
      In this regard, such simulation are exactly matching the representation
      of molecular dynamics simulations. These track atoms, from whose configuration
      in a snapshot a description has to be computed what are most likely the
      atoms that belong to the volume of the crystal or the interface/defect 
      network.
  # for implicitly tracking simulation one can also argue that as
  # one anyway needs to do post-processing to extract at all what the grains
  # one could also group fields from this base class into an NXprocess
  # the fundamental problem making a decision is that depending on which
  # model and implementation is used some of these post-processes are
  # executed on-the-fly, so from the perspective of an application definition
  # the internal workflows in the software are irrelevant but instead one
  # just cares what is reported as a result from the software
  # !!! this example nicely shows that drafting an application definition is
  # !!! eventually also demanding to make a somewhat arbitrary cutting of the 
  # !!! workflow steps, tag this sub-workflow as some entity 
  # !!! (e.g. the phase field simulation)
  # !!! and thus have application definitions that merely assure specific data
  # !!! are passed into this sub-graph or expect as output from the sub-graph
  # !!! in a particular application
  # a general enough phase-field description needs to account for the 
  # fact that not necessarily each region is crystalline
  symbols:
    d: "Dimensionality"
    n_objects: "Number of objects. Objects can be crystals, grains, phases,
    or phase field regions."
  # how can we elegantly implement that in simulations where the number
  # of objects remains static that the identifier are not changing with 
  # each iteration, so there is no need to store them here.
  number_of_objects(NX_UINT):
    unit: NX_UNITLESS
  identifier_offset(NX_UINT):
    doc: "Integer which specifies the first index to be used for distinguishing
    objects. Identifier are defined either implicitly or explicitly. For implicit indexing identifiers are on the interval [identifier_offset, identifier_offset+c-1]. For explicit indexing the identifier array has to be used.  The identifier_offset describes e. g. if object IDs start from 1 (also referred to as the Fortran-), 
    from 0 (also referred to as C-, Python-style notation), or from a different offset, which is best suited to support the description respectively."
  identifier(NX_UINT):
    doc: "Integer used to distinguish objects when for explicit indexing."
    dimensions:
      rank: 1
      dim: [[1, n_objects]]
  object_size(NX_NUMBER):
    doc: "Area or volume for each object"
    dimensions:
      rank: 1
      dim: [[1, n_objects]]
  # add further object specific properties
  # (NXms_orientation_set):
  # (NXms_dislocation_set):
  # (NXms_boundary_set):
  # (NXms_triple_line_set):
  # (NXms_quadruple_junction_set):
 