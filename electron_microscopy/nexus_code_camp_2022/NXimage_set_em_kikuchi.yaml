category: base
symbols:
  n_p: Number of scan points, one pattern per scan point.
  n_y: Number of pixel per Kikuchi pattern in the slow direction
  n_x: Number of pixel per Kikuchi pattern in the fast direction
doc: |
  Electron backscatter diffraction (EBSD) Kikuchi pattern.
  
  The container can also store data related to a post-processing of these
  Kikuchi pattern, which is the backbone of orientation microscopy
  especially in materials science and materials engineering.
  
  Based on a fuse of the `M. A. Jackson et al. <https://doi.org/10.1186/2193-9772-3-4>`_
  of the DREAM.3D community and the open H5OINA format of Oxford Instruments
  `P. Pinard et al. <https://doi.org/10.1017/S1431927621006103>`_
  
  EBSD can be used, usually with FIB/SEM microscopes, for three-dimensional
  orientation microscopy. So-called serial section analyses. For a detailed
  overview of these techniques see e.g.
  
  * `M. A. Groeber et al. <https://doi.org/10.1186/2193-9772-3-5>`_  
  * `A. J. Schwartz et al. <https://doi.org/10.1007/978-1-4757-3205-4>`_  
  * `P. A. Rottman et al. <https://doi.org/10.1016/j.mattod.2021.05.003>`_  
  
  With serial-sectioning this involves however always a sequence of
  measuring, milling. In this regard, each serial section (measuring) and milling
  is an own NXevent_data_em instance and thus there such a three-dimensional
  characterization should be stored as a set of two-dimensional data,
  with as many NXevent_data_em instances as sections were measured.
  
  These measured serial sectioning images need virtually always post-processing
  to arrive at the aligned and cleaned image stack respective digital
  microstructure representation as (a representative) volume element.
  Several software packages are available for this post-processing.
  For now we do not consider metadata of these post-processing steps
  as a part of this base class.
# NEW ISSUE: the above-mentioned post-processing could be added though via a (NXprocess)
(NXimage_set_em_kikuchi):
  # a collection of pattern-related metadata
  (NXdata):
    doc: | 
      Collected Kikuchi pattern as an image stack.
    intensity(NX_NUMBER):
      unit: NX_UNITLESS
      dimensions:
        rank: 3
        dim: [[1, n_p], [2, n_y], [3, n_x]]
      \@long_name:
        doc: Kikuchi pattern intensity
    # \@signal: intensity
    # \@axes: [image_id, ypos, xpos]
    # \@image_id_indices: 0
    # \@ypos_indices: 1
    # \@xpos_indices: 2
    image_id(NX_NUMBER):
      unit: NX_UNITLESS
      dimensions:
        rank: 1
        dim: [[1, n_p]]
      \@long_name:
        doc: Kikuchi pattern identifier
    ypos(NX_NUMBER):
      unit: NX_LENGTH
      dimensions:
        rank: 1
        dim: [[1, n_y]]
      \@long_name:
        doc: Label for the y axis
    xpos(NX_NUMBER):
      unit: NX_LENGTH
      dimensions:
        rank: 1
        dim: [[1, n_x]]
      \@long_name:
        doc: Label for the x axis
  # post-processing into EBSD mappings follows, here an example for 2D map
  # if the pattern is a regular grid
  # NEW ISSUE: use cg classes
  # (NXgrid):
    # number of pixels
    # step size
  # what about examples for a 1D map and a 3D map?
  # NEW ISSUE: one could do a reanalyzing with having a collection of NXprocesses
  grid_type:
    doc: Which pixel primitive shape is used.
    enumeration: [square, hexagon]
  step_size(NX_NUMBER):
    doc: |
      The prescribed step size. First value is for the slow changing, 
      second value is for the fast changing dimension.
    unit: NX_LENGTH
    dimensions:
      rank: 1
      dim: [[1, 2]]
  calibration(NXprocess): ##MK gain etc on the detector
  oim(NXprocess):
    doc: |
      OIM, orientation imaging microscopy.
      Post-processing of the Kikuchi pattern to identify orientations.
    pattern_quality(NX_FLOAT):
      unit: NX_UNITLESS
      dimensions:
        rank: 1
        dim: [[1, n_p]]
    pattern_center(NX_NUMBER):
    # NEW ISSUE: replace by (NXcg_point_set):
      unit: NX_LENGTH
      dimensions:
        rank: 1
        dim: [[1, n_p]]
    detector_distance(NX_FLOAT):
      unit: NX_LENGTH
      dimensions:
        rank: 1
        dim: [[1, n_p]]
    background_correction(NXprocess):
      doc: Details about the background correction applied to each Kikuchi pattern.
    # NEW ISSUE:
    # auto_background_correction:
    # static_or_dynamic:
    band_detection(NXprocess):
      mode:
        doc: How are Kikuchi bands detected
        enumeration: [center]
      band_contrast(NX_NUMBER):
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      band_slope(NX_NUMBER):
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      bands(NX_NUMBER):
        doc: How many bands were detected in the pattern.
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
    indexing(NXprocess):
      # NEW ISSUE: for now as collections, with microstructure proposal NXreflectors
      reflector(NXcollection):
        doc: |
          Lattice planes used as reflectors for indexing pattern
          in electron-backscatter diffraction (EBSD).
          One collection for each reflector.
        unit_cell_abc(NX_FLOAT):
          doc: Crystallography unit cell parameters a, b, and c
          unit: NX_LENGTH
          dimensions:
            rank: 1
            dim: [[1, 3]]
        unit_cell_alphabetagamma(NX_FLOAT):
          doc: Crystallography unit cell parameters alpha, beta, and gamma
          unit: NX_ANGLE
          dimensions:
            rank: 1
            dim: [[1, 3]]
        unit_cell_class:
          enumeration: [triclinic, monoclinic, orthorhombic, tetragonal, rhombohedral, hexagonal, cubic]
        space_group:
          doc: Crystallographic space group
        laue_group:
          doc: Laue group
        phase_identifier(NX_UINT):
          doc: Numeral identifier for each phase. The value 0 is reversed for the unknown phase.
          unit: NX_UNITLESS
        phase_name:
          doc: Name of the phase/alias.
        number_of_reflectors(NX_UINT):
        miller_indices(NX_NUMBER):
          doc: Miller indices :math:`(hkl)[uvw]`.
          unit: NX_UNITLESS
          dimensions:
            rank: 2
            dim: [[1, number_of_reflectors], [2, 6]]
      mode:
        doc: How are pattern being indexed?
        enumeration: [optimize_bd]
      # NEW ISSUE: what doesoptimize_bd mean Oxford?
      min_bands(NX_NUMBER):
        doc: Minimum number of bands required to index the pattern
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      status(NX_NUMBER):
        doc: |
          Which return value did the indexing algorithm yield for each pattern.
          
          * Details about bad pixels  
          * Too high angular deviation  
          * No solution  
          * Not analyzed  
          * Success  
          * Unexpected errors  
          
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      phase_identifier(NX_UINT):
        doc: Labels referring to the phase_identifier for each pattern (from reflectors) that matched best.
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      # NEW ISSUE: (NXorientation_set):
      mean_angular_deviation(NX_FLOAT):
        unit: NX_ANGLE
        dimensions:
          rank: 1
          dim: [[1, n_p]]
      confidence_index(NX_FLOAT):
        unit: NX_UNITLESS
        dimensions:
          rank: 1
          dim: [[1, n_p]]
  # on the other hand there are specific metadata to store with taking EBSD
  # mappings
  # tilt_angle(NX_FLOAT):
  # maybe better make this integrated into the NXtransformations of the stage_lab, a stage_lab event?
  # beam_position(NXcg_point_set):
  # (NXdetector):
  #   exposure_time(NX_FLOAT):
  #     unit: NX_TIME
  #   gain(NX_FLOAT): 
  #   ##MK how does a gain translate mathematically an input signal into an intensity signal?
  #   insertion_distance(NX_FLOAT):
  #     unit: NX_LENGTH
  #   ##MK a coordinate system for the detector in the NXcoordinate_system_set
  #   drift_correction(NX_BOOLEAN): ##MK??
  binning(NXcollection):
    mode:
      doc: Free-text description for instrument specific settings
    # NEW ISSUE: binning replace by NXgrid
    binning(NX_UINT): ##MK equivalent to pattern height and width?
      doc: |
        How is the camera signal binned.
        First the number of pixel along the slow direction.
        Second the number of pixel along the fast direction.
      unit: NX_UNITLESS
      dimensions:
        rank: 1
        dim: [[1, 2]]
  hough_transformation(NXprocess):
    resolution(NX_NUMBER):
      unit: NX_UNITLESS
  profiling(NXcollection):
    acquisition_speed(NX_FLOAT):
      doc: Average number of patterns taken on average.
      unit: NX_FREQUENCY
    acquisition_time(NX_FLOAT):
      doc: Wall-clock time the acquisition took.
      unit: NX_TIME
    hit_rate(NX_FLOAT):
      doc: Fraction of successfully indexed pattern of the set.
      unit: NX_DIMENSIONLESS
  # NEW ISSUE: frame averaging
  # NEW ISSUE: going towards the level of suggestions what would all be immediately possible
  # ebsd_mapping(NXprocess):
  #   doc: |
  #     An EBSD mapping is the result of a collecting and indexing of Kikuchi
  #     pattern, so that for each pattern there is either an associated
  #     phase_identifier or a status marker stating that no solution was found
  #   (NXsst_color_model): ##MK
  #     doc: |
  #       For each stereographic standard triangle, (fundamental zone) of 
  #       the orientation space, it is possible to define a color model which
  #       associates an orientation in the fundamental zone to a color.
  #       
  #       For details see:
  #       * [G. Nolze et al.](https://doi.org/10.1107/S1600576716012942)
  #       * Srikanth Patala and coworkers"'" work and of others.
  #     (NXorientation_set):
  #       doc: |
  #         Collection of quaternions in the SO3 fundamental zone with colors and
  #         details about how to plot the stereographic standard triangle (SST).
  #       rgb(NX_NUMBER):
  #         doc: RGB colors.
  #         unit: NX_UNITLESS
  #         dimensions: [[1, n_oris], [2, 3]]
  #       # hsv and other models
  #       (NXcg_point_set):
  #         rgb(NX_NUMBER):
  #           dimensions: [[1, n_points], [2, 3]]
  #   mapping(NX_NUMBER):
  #     doc: | 
  #       The EBSD mapping with colors outlined
  #     unit: NX_UNITLESS
  #     dimensions: [[1, n_y], [2, n_x], [3, 3]]
  # NEW ISSUE: it would also be possible to define additional color models to overlay
